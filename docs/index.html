<!DOCTYPE HTML>
<html xml:lang="en" lang="en">

<head>
  <title>CSE512 | Final Project</title>

  <link rel="stylesheet" href="css/site.css">
  <link rel="stylesheet" href="css/vis.css">
</head>

<body>
  <div class="content">
    <section class="title">
      <a href="">Codemap</a>
      <a href="https://github.com/cse512-21s/FP-Codemap">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"
          focusable="false" width="0.75em" height="0.75em"
          style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);"
          preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 250">
          <path
            d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46c6.397 1.185 8.746-2.777 8.746-6.158c0-3.052-.12-13.135-.174-23.83c-35.61 7.742-43.124-15.103-43.124-15.103c-5.823-14.795-14.213-18.73-14.213-18.73c-11.613-7.944.876-7.78.876-7.78c12.853.902 19.621 13.19 19.621 13.19c11.417 19.568 29.945 13.911 37.249 10.64c1.149-8.272 4.466-13.92 8.127-17.116c-28.431-3.236-58.318-14.212-58.318-63.258c0-13.975 5-25.394 13.188-34.358c-1.329-3.224-5.71-16.242 1.24-33.874c0 0 10.749-3.44 35.21 13.121c10.21-2.836 21.16-4.258 32.038-4.307c10.878.049 21.837 1.47 32.066 4.307c24.431-16.56 35.165-13.12 35.165-13.12c6.967 17.63 2.584 30.65 1.255 33.873c8.207 8.964 13.173 20.383 13.173 34.358c0 49.163-29.944 59.988-58.447 63.157c4.591 3.972 8.682 11.762 8.682 23.704c0 17.126-.148 30.91-.148 35.126c0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002C256 57.307 198.691 0 128.001 0zm-80.06 182.34c-.282.636-1.283.827-2.194.39c-.929-.417-1.45-1.284-1.15-1.922c.276-.655 1.279-.838 2.205-.399c.93.418 1.46 1.293 1.139 1.931zm6.296 5.618c-.61.566-1.804.303-2.614-.591c-.837-.892-.994-2.086-.375-2.66c.63-.566 1.787-.301 2.626.591c.838.903 1 2.088.363 2.66zm4.32 7.188c-.785.545-2.067.034-2.86-1.104c-.784-1.138-.784-2.503.017-3.05c.795-.547 2.058-.055 2.861 1.075c.782 1.157.782 2.522-.019 3.08zm7.304 8.325c-.701.774-2.196.566-3.29-.49c-1.119-1.032-1.43-2.496-.726-3.27c.71-.776 2.213-.558 3.315.49c1.11 1.03 1.45 2.505.701 3.27zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033c-1.448-.439-2.395-1.613-2.103-2.626c.301-1.01 1.747-1.484 3.207-1.028c1.446.436 2.396 1.602 2.095 2.622zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95c-1.53.034-2.769-.82-2.786-1.86c0-1.065 1.202-1.932 2.733-1.958c1.522-.03 2.768.818 2.768 1.868zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37c-1.485.271-2.861-.365-3.05-1.386c-.184-1.056.893-2.114 2.376-2.387c1.514-.263 2.868.356 3.061 1.403z"
            fill="#161614" />
          <rect x="0" y="0" width="256" height="250" fill="rgba(0, 0, 0, 0)" />
        </svg>
      </a>
    </section>

    <section>
      <p>
        <strong>Team Members</strong>: Thomas Schweizer
      </p>
      <p>
        <a href="https://www.youtube.com/watch?v=sHH-MWpzAW0">Video presentation</a>
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        As part of an ongoing <a href="https://www.notion.so/Codemap-ec02c79cb0b44304ba10767af1ca3788">research
        project</a>, we explore multiple software visualization concepts aimed to help developers explore and locate
        information about methods and classes necessary to fix bugs and develop new features. We also explore related work in software visualization and visualization evaluation. We present our results with a short project report and two visualizations.
      </p>

      <p>
        Previously, we conducted a user study to evaluate if an integrated interactive visualization to an IDE was
        useful to developers to navigate source code and find related classes and methods [<a
        href="#ref-codemap">9</a>]. For this we developed a <a
        href="http://amy.zhucchini.ca/503-hacking/vis/index.html">rough prototype</a> to support the experiment. The
        visualization used a zooming technique, similar to Google Maps, to move vertically between different levels of
        abstraction (e.g., low-level implementation details) and horizontally within one abstraction level (e.g.,
        exploring method dependencies). All the software artifacts (e.g., method, classes, packages) are represented as
        nodes in a multi-scale network graph where the edges represent the dependency relationships between the
        artifacts. The visualization is instantiated from the developer's IDE and centered on the class in the text
        editor. Conversely, control-clicking on a class will switch back to its source code. The visualization is
        described in more details in <a href="https://github.com/amyjzhu/503-hacking/">its repository</a>.
      </p>

      <p>
        Overall, we found that the visualization was generally helpful to the participants. The following
        features were particularly well-received and promising:
        <ul>
          <li>The visualization is initially centered on the class the user is editing</li>
          <li>Moving seamlessly between levels of abstraction visually (similarly to Google Maps)</li>
          <li>Switching between the source code of a class and its visualization with a click</li>
          <li>Exploring dependencies interactively (by clicking on the edge connecting the methods or classes)</li>
        </ul>
      </p>

      <p>
        We also found that the representation of each level of abstraction was lacking. Participants complained that
        packages, classes, and methods were too far apart or too close together, creating occlusion problems in the
        latter case. These issues stem from the force layout we used. We also ran into performance and complexity issues
        with larger codebases that we mitigated with interactive filters and just-in-time rendering.
      </p>

      <p>
        Thus, with this final project, we aim to explore visualization concepts to represent different levels of
        abstraction in source code capable of addressing these issues. The visualizations will be focused on working
        from a local perspective (i.e., showing dependencies from a given method rather than showing the entire
        dependency graph) and interactivity on top of existing visualization techniques (e.g., Voronoi, Hyperbolic
        Layout, Hierarchical Edge Bundling, Radial Tree).
      </p>

      <p>
        This project will not implement the mechanisms to blend the visualization of the levels of abstraction; this
        will be for another time. Additionally, this project will not focus on integrating the visualization and the IDE
        because the previous prototype already implemented the basic mechanisms. Moreover, in the visualization concepts
        below, we implicitly assume that the visualizations are implemented in the context of a development environment
        that would update the data model with the most up-to-date information. Crucially, we also implicitly keep the
        interaction feature of control-clicking introduced in the legacy prototype that enables the user to switch
        between an element in the visualization to its source code equivalent.
      </p>

      <p>
        We describe each visualization concept designed for this project using Munzner's nested model [<a href="#ref-munzner">4</a>].
      </p>

      <p>
        The report is organized as follows. 
        First, we explore related work 
        (<a href="#ref-related-work">Related work</a>). 
        Second, we state the main challenges we anticipate to face our visualizations 
        (<a href="#ref-challenges">Challenges</a>).
        Third, we design and discuss an overview for visualizing the structure of software 
        (<a href="#ref-structure-overview">Structure overview</a>).
        Fourth, we design and discuss a visualization for exploring local method dependencies 
        (<a href="#ref-local-exploration">Local exploration</a>).
        Finally, we conclude the project with a brief summary 
        (<a href="#ref-conclusion">Conclusion</a>).
      </p>

      <!-- 
        Related work
       -->
      <h2 id="ref-related-work">Related work</h2>
      <p>
        In our initial survey literature, we retained papers that we deemed most relevant and representative to serve as a starting point for snowball sampling [<a href="#ref-snowball">25</a>]. Chotisarn et al., dress an exhaustive portrait of the software visualization research landscape in a recent paper [<a href="#ref-chotisarn-survey">23</a>]. Using a systematic review literature methodology, they retained 105 relevant full papers on software visualization. In addition of highlighting research opportunities, the paper also provide effective tools to orient and scope research in software visualization. This article is thus doubly useful for us. Moreover, they classify the relevant papers by software system aspect (i.e., structure, behavior, evolution [<a href="#ref-diehl">24</a>]), software process (i.e., specification, design & implementation, validation & testing, evolution), and role (i.e., developer, maintainer, manager) as well as visualization technique, mediums and tools.
      </p>

      <p>
        We identified Pretorius et al. [<a href="#ref-pretorius">13</a>] taxonomy for general tasks in graph networks as a promising source to describe and scope the developer's tasks when software is represented with the metaphor of a network graph such as software artifacts (e.g., classes, methods, packages) are represented as nodes and the relations between them (e.g., dependency, inheritance, flow) as edges.
        
        Additionally, Elmqvist et al., [<a href="#ref-elmqvist-hierarchical">8</a>] present a general technique to visualize multi-scale representation of hierarchical information, which is helpful since many aspects of software development are hierarchical (e.g., architecture, dependencies).
      </p>

      <h3>Solutions</h3>
      <p>
        Finally, we explored commercial and open-source solutions to get a picture of the landscape as complete as possible. We found surprisingly many solutions and approaches. Most of them concentrate on audit-type visualizations where big picture is presented to the viewer [<a href="#ref-depwheel">15-20</a>], although a portion of them are bit more "esoteric" such as Gource [<a href="#ref-gource">10</a>] and CodeFlower [<a href="#ref-codeflower">14</a>]. We also found that a minority of solutions are integrated with the developer's workflow [<a href="#ref-ndepend">20-22</a>].
      </p>
      <p>
        We found that NDepend [<a href="#ref-ndepend">20</a>] was the closest to our overall idea, implementing a zooming mechanism enabling the user to drill down at will. See <a href="https://blog.ndepend.com/visualize-code-with-software-architecture-diagrams/">this article</a> for a detailed look. Sourcetrail [<a href="#ref-sourcetrail">7</a>] also caught our attention because it seemed to be the most thoughtful solution out there. Indeed, it addresses a clear problem well and the user interface seems intuitive and well thought-out so as to not overwhelm the viewer.
      </p>

      <h3>Venues</h3>
      <p>
        Through the course and initial literature survey, we identified relevant venues for software visualization such as <a href="https://chi2021.acm.org/">CHI</a>, <a href="https://uist.acm.org">UIST</a>, <a href="http://ieeevis.org/year/2021/welcome">IEEE VIS</a>, <a href="https://vissoft20.dcc.uchile.cl/">IEEE VISSOFT</a>, <a href="https://www.eurovis.org/">EuroVis</a>, and <a href="https://www.springer.com/journal/12650">Journal of Visualization</a>. These references will be helpful to gather the latest state of the art and communicate our research using the methods and conventions used by the visualization community in addition to the software visualization survey paper [<a href="#ref-chotisarn-survey">23</a>].
      </p>

      <!-- 
        Challenges
       -->
      <h2 id="ref-challenges">Challenges</h2>

      <p>
        In this section, we list some of the challenges we'll face in visualizing software and discuss potential
        solutions.
      </p>
      
      <h3>Perception</h3>
      <p>
        The biggest challenge is to design a readable visualization by the user of the visualization, the developer. It
        is vital in visualizing software as the complexity of source code can explode very fast. We know that human
        perception has limits and conditions, as seen during the course with Healy et al. [<a
        href="#ref-healey-attention">26</a>] notably. A good example of this phenomenon is the  <em>Deutsch limit</em>
        suggesting that humans have a fairly low limit on the number of entities they can keep in memory at any given
        moment [<a href="#ref-deutsch">27</a>] (Has the Deutsch limit ever been verified? I remember reading an article
        where the actual number was way below the Deutsch limit).
      </p>

      <p>
        While difficult to remove entirely, there are several options to mitigate the strain placed on the user. In our
        initial prototype, the zooming mechanism enabling vertical exploration (i.e., low-level implementation details
        to high-level abstraction) already "slices" the visualization in various visualizations that are conceptually
        different, so we do not show low-level details mixed with high-level details abstractions. 
    
        Moreover, using specific filtering and interaction techniques for each visualization concept enables us to fully
        leverage the visualization support for this level and ease the visualization experience.
      </p>

      <p>
        Another important feature we can include is supporting visual scanning through pre-attentive perception. We
        implement this principle in our design concepts by using grayscale colors for the bulk of the elements shown and
        using accent colors to bring attention to important elements that need to "pop."
      </p>

      <h3>Representation</h3>
      <p>
        Representing software is difficult because it doesn't have an inherent physical representation that the
        developer can identify intuitively. The same observation was made by Tufte regarding the conundrum of
        representing <em>information</em> such as comparing two measures, or more generally showing statistics [<a
        href="#ref-tufte">28</a>]. Fortunately, this is somewhat mitigated by the fact that developers are used to
        thinking abstractly and already use common symbols (e.g., UML) to communicate more or less formally about
        software systems, behavior, and architecture. Nonetheless, we need to be careful that the visualization is not
        going against these colloquially accepted symbols and that we stay consistent across the visualization levels.
        In a sense, we will need to build a consistent visual grammar in syntax across the visualization levels.       
      </p>

      <p>
        Another concern is how to layout the different elements shown in the visualization. We have seen established
        strategies in class that address the question. Still, in representing some aspects of the software as a network
        graph, the answers are not as clear cut as gathered in our initial user study. In one visualization concept, we
        explore an adapted approach to represent a coherent overview of the structure of a system. In the other concept,
        we explore how to represent a network graph using various techniques.
      </p>

      <h3>Performance</h3>
      <p>
        The lecture on "Scalable Visualization" gave us many pointers to make our visualization efficient and
        responsive. More importantly, it gave us a good insight into how much work is required to handle visualizations
        with a large amount of data as it may be the case in the context of visualizing software -- That is, without
        even considering the inherent scalability issues for parsing the source code alone.
      </p>

      <h3>Evaluation</h3>
      <p>
        Lastly, we need to address how to evaluate our concepts as seen in class with Nekrasovski et al. [<a
        href="#ref-nekra">30</a>], it's crucial to gather user feedback as soon as possible and continue to do so when
        significant changes have been made.  We already conducted user feedback in an early user study on a rough
        prototype. As we advance, we will evaluate our different visualizations using the techniques seen in the course
        and literature. Additionally, we can now qualify the performance of visualization to the task it's intended to
        solve in terms of efficiency and efficacy.
      </p>

       <!-- 
        Structure overview
       -->
      <h2 id="ref-structure-overview">Structure overview</h2>
      <p>
        In this prototype, we explore how the class and package hierarchy can be visualized from the perspective of an
        initial class using Voronoi diagrams (implemented with <a
        href="https://github.com/Kcnarf/d3-voronoi-treemap">d3-voronoi-treemap</a>). Drawing from our pilot study, we maximize the use of screen space to avoid having classes and packages unconnected or unreasonably far away.
      </p>

      <details>
        <summary>Initial nested model for hierarchy concept</summary>
        <div class="nested-model">
          <div class="domain">
            <p><strong>Domain Problem and Data Characterization</strong></p>
            <p>
              We are interested to help the developer build a mental image of the source code. Mental image of the
              source code is necessary before fixing a bug or implementing a new feature to locate artifacts or
              interest.
            </p>
            <p>
              Conducted a user study on a rough visualization prototype integrated to Visual Studio Code as a plugin to
              gather initial feedback. Participants noted that integration was really important and used the zooming
              mechanism to move from low abstraction to high abstraction.
            </p>

            <div class="abstraction">
              <p><strong>Operation and Data Type Abstraction</strong></p>
              <p>Transform the class and package hierarchy into a list of parent and children relations. The hierarchy
                is illustrated with Voronoi treemaps [<a href="#ref-balzer-voronoi-treemap">2</a>].</p>

              <div class="technique">
                <p><strong>Visual Encoding and Interaction Design</strong></p>

                <p>The class and package hierarchy is encoded as a greyscale Voronoi treemap.The cells represent
                classes and the edges represent class and packages boundaries.</p>

                <p>The current class is encoded with an <span style="background-color:aquamarine">accent color</span>
                  for pre-attentive detection.</p>

                <p>To anchor the representation physically to the viewer, we encode the cell's size with the size of the
                  class. Here, we use the source lines of code (SLOC) metric to represent the size [<a
                    href="#ref-loc">5</a>]. That way, each cell is characterized by its content visually.</p>

                <p>Hovering displays information regarding the class and enclosing package</p>

                <p>Search bar to find a class quickly.</p>

                <p>Control clicking a class, centers the visualization on it</p>

                <p>Inter class or package relations (e.g., dependencies) can be toggled on and off with an extradiegetic
                interface.</p>

                <div class="algorithm">
                  <p><strong>Algorithm Design</strong></p>
                  <p>
                    Voronoi treemaps [<a href="#ref-d3-voronoi-treemap">1</a>, <a
                      href="#ref-balzer-voronoi-treemap">2</a>]
                  </p>

                  <p>
                    The diagram is seeded so the map doesn't change every time its regenerated even though the content
                    of the data doesn't change. The seed is assigned to the data so every time the data changes, a new
                    map is generated, marking a new version of the data. In a live development setting, we would need a
                    less naive approach. For example, growing the map as changes are made, minimizing displacement of
                    the cells similarly how Gource [<a href="#ref-gource">10</a>], a popular version control
                    visualization, does it.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </details>

      <div id='vis-macro' class="visualization"></div>
      <div id='vis-macro-legend' class="legend"></div>
      <p class="hint">Refresh the page to change the point of view (i.e., current class)</p>

      <h3>Discussion</h3>
      <p>
        Although this visualization lacks some of the features we envisioned, such as a search bar and a miniature of
        the currently hovered polygon next to the tooltip for the class, we are satisfied with the concept. We believe
        that the current design does better than the pilot prototype in giving a coherent customized overview that is
        intuitively understandable and explorable. A detail that we particularly like is the contrast between the
        greyscale encoding for the polygons' edges and fill, and the complementary accent colors to bring attention the
        <span style="background-color: aquamarine;">current class</span> and the <span style="background-color:
        #FF7FAA;">hovered class</span>.
      </p>

      <p>
        Moreover, we feel that this iteration is closer conceptually to a map than the previous solution implemented in
        the pilot prototype using a network graph to visualization the structure hierarchy. Like any map, an overview
        emerges naturally and is explorable easily either through panning or zooming without gaining or losing critical
        information or breaking context. Elements are separated by borders of varying sizes depending on their enclosing
        concept, and an increasingly darker shade encodes the hierarchy's depth using through the cells' background (but
        never too dark to be unreadable or draw unwanted attention). This format also lends itself naturally to
        extending abstraction: as we zoom, we can show different information inside the polygon. For example, zooming
        sufficiently out might only show package names. Conversely, zooming in shows increasing details on the packages,
        then switches to present information about classes. This extension should mitigate the problem of oversized fonts for their cell, difficult to read text, and difficulty to retain the packages names.
      </p>

      <p>
        There are two significant missing features to make this concept whole. The first one, as mentioned previously,
        is the search bar enabling developers to locate an element directly instead of scanning for it. Still, we can
        easily imagine how it would be integrated as an extradiegetic control. The second feature is an interactive
        overlay of relationships between the current and selected classes (through clicking, not currently implemented)
        encoded with hierarchical edge bundles [<a href="ref-hierarchical-bundles">12</a>].
      </p>

      <p>
        Overall, we find this concept promising and are looking forward to exploring and tweaking it further after
        getting initial feedback from peers and evaluating it.
      </p>

      <!-- 
        Local exploration
       -->
      <h2 id="ref-local-exploration">Local exploration</h2>
      <p>
        In this prototype, we explore how dependencies between methods can be explored from the perspective of an initial method, centered in the visualization.
      </p>

      <details>
        <summary>Initial nested model for method visualization</summary>
        <div class="nested-model">
          <div class="domain">
            <p><strong>Domain Problem and Data Characterization</strong></p>
            <p>
              We are interested to help the developer build a mental image of the source code. Mental image of the
              source code is necessary before fixing a bug or implementing a new feature to locate artifacts or
              interest.
            </p>
            <p>
              Conducted a user study on a rough visualization prototype integrated to Visual Studio Code as a plugin to
              gather initial feedback. Participants noted that integration was really important and made heavy use of
              click through to go from one method to another. Also found the zooming feature useful to answer questions.
            </p>

            <div class="abstraction">
              <p><strong>Operation and Data Type Abstraction</strong></p>
              <p>Network graph. Edges are links between artifacts. Nodes are methods.</p>

              <div class="technique">
                <p><strong>Visual Encoding and Interaction Design</strong></p>
                <p>Methods are encoded as network nodes. Their size is based on the method's LOC or complexity, the
                  color encodes method's class.</p>

                <p>Methods are attracted by their enclosing class and dependencies.</p>

                <p>The dependencies are encoded as the edges.</p>
                <p>
                  <strong>Interactions:</strong>
                <ul style="list-style: none">
                  <li>Hide / Show artifact</li>
                  <li>Pin / Unpin artifact</li>
                  <li>Navigate: click on links, zoom, pan</li>
                </ul>
                </p>

                <p>
                  Current path is highlighted.
                </p>

                <div class="algorithm">
                  <p><strong>Algorithm Design</strong></p>
                  <p>Voronoi, Hyperbolic Layout, Hierarchical Edge Bundling, Radial Layout</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </details>

      <div id='method-level' class="visualization"></div>
      <p class="hint">Refresh the page to change the point of view (i.e., current method)</p>

      <h3>Discussion</h3>

      <p>
        Admittedly, this prototype hasn't been developed very far. However, it doesn't diminish its usefulness as a
        design concept. In addition to being a great D3 learning experience (we made this one first), the visualization
        is very effective at showing whether the current method calls any other method in the source code, as
        illustrated by the presence or absence of edges connected to the center node. Overall, centering the
        visualization on the current method under investigation worked very well in anchoring the visualization and
        establishing context.
      </p>

      <p>
        This visualization was the hardest to implement, and we had to scale down our ambitions to fit in the course's
        timeline. Adjusting the force layout and finding the right way to center a node in the force system were
        particularly challenging. We found promising examples online that showcase behaviors that we might implement
        later.  Nonetheless, with this visualization, we were able to acquire a lot of experience on the d3 force layout
        and develop my instincts for a good visualization for network graphs in the context of software visualization.
      </p>

      <p>
        While implementing this concept, we were able to explore layout systems for network graphs. After initial trials
        with force layout, we considered a radial tree layout and a hyperbolic layout since we had an explicit center
        node. After further considerations, we discarded the hyperbolic layout because this layout is not the easiest to
        read. To quote the course, "People don't read in circle." In the already demanding context of perceiving
        inter-connected methods, we preferred not to strain the developer if we could avoid it. We discarded the radial
        tree out of concern for representing relationships between nodes because our graph is far from being a tree --
        there is not a true center root for the whole graph, thus placing all nodes relative to the center might not
        make sense -- and that edges unrelated to the center node can zip through the center and clutter the
        visualization. Solving the excess of edges with a hyperbolic layout would not be efficient since the viewer
        still has no use for unrelated edges. Filtering these unrelated edges doesn't solve the problem either because
        it will leave many isolated nodes gravitating aimlessly around the center, adding to the clutter.
      </p>

      <p>
        Color is also problematic as implemented currently. It might give some clue as to which nodes belong to the same
        class, but the lack of legend makes it challenging to know for sure because applications are routinely composed
        of many different classes far exceeding ordinary color schemes and ending up repeating. For the same reason, a
        global color legend would not be helpful: there are too many classes to show. In the end, we decided to show the
        class using a tooltip when the user hovers on a node. Our initial plan was to group methods together by gravity
        and overlay the group with a light color border, but we lacked time to implement it properly (we found some
        great examples along the way for later, though).
      </p>

      <p>
        We realized that centering the current method was a good first step that was ultimately insufficient. Indeed, as
        seen in class, showing more isn't always better. In this particular case, displaying all the nodes is doing the
        developer a disservice since the task we want to support is to help them explore local relationships from a
        particular method: they do not need to see unrelated classes and methods. They will most likely never visit
        random nodes and edges, just like they never open random source files to locate information while developing
        within their IDE. They always either 1) follow type dependencies or 2) search for a specific artifact. Thus, we
        refined our design further.
      </p>

      <h3>Second iteration</h3>

      <p>
        For this second design, the amount of information shown is directly controlled by the developer through
        interaction. The developer would build up the visualization from a minimal initial set of nodes;  this solves
        our earlier problems regarding unrelated edges and nodes, and color overload. The hope is that by starting with
        a minimal visualization, the developer auto-regulates the complexity they need displayed, enabling them to focus
        on different aspects in function of the information they need at the time.
      </p>

      <p>
        Picture this. The visual metaphor is still a network graph with methods and classes represented as nodes, and
        the edges represent the type of dependencies. The visualization initially shows only direct dependencies related
        to the method under visualization (referred to as 'origin method'). The dependency nodes include the type of
        parameters, type of variables, classes used, method used, and methods using the origin method. Incoming and
        outgoing dependencies are differentiated with corresponding arrows. For example, a node representing a parameter
        type of the origin method has an incoming arrowed edge to the origin's node. In contrast, an outgoing arrowed
        edge would connect to a node representing where the method is called from. The visualization is still centered
        on the origin method. The related nodes are organized using a force layout where similar nodes tend to group
        (e.g., type parameter). Alternatively,  borrowing from topology trees, types and methods far away semantically
        or package-wise would be shown less close to the center node than its immediate related nodes such as methods in
        the same class or package.
      </p>

      <p>
        Clicking on a node (except the origin) will, in turn, expand the dependencies of the clicked node, just like for
        the origin method, and center the visualization on this new node of focus. A breadcrumb mechanism highlights the
        path (i.e., making the edges thicker) between the origin node and the node currently in focus (or hovered),
        allowing the developer to visually have a reference for tracing back their steps, much like how Ariadne's thread
        allowed Theseus to escape the Minotaur's labyrinth in the eponym greek myth. We also include an extra-diegetic
        control on the bottom left of the visualization allows the developer at any time to focus the visualization back
        to the origin node, so they don't have to follow the breadcrumb. This is especially useful if they have explored
        a large network and do not want to scroll or pan all the way back.
      </p>

      <p>
        Hovering on an edge or a node gives contextual clues such as the name of the method, class, and parameter, similar to how the quick access documentation might show in an IDE. We prefer keeping the amount of textual information on the graph light not to clutter the graph to encourage the developer to explore.

        The developer can also drag and pin nodes to arrange their graph how they like or see it. We could imagine an
        advanced feature where we learn their positioning preference automatically to reposition the nodes for them,
        relying less on the force layout's idiosyncrasies.
      </p>

      <p>
        Similar to the previous visualization concept, we encode the size of the nodes with the size of the method
        (e.g., SLOC [<a href="#ref-loc">5</a>, <a href="#ref-cloc">6</a>]) to give the nodes a "physical" anchor to their source code counterparts.
        We hope that this will help developers intuitively form a connection between the methods' source code and their
        visual representation.

        Finally, edge bundling could be leverage here when the developer zooms back and forth as a way to highlight common fate patterns and be easier on the eye and performance [<a href="#ref-hierarchical-bundles">12</a>].
      </p>

      <p>
        To further help the developer parse the graph quickly, we are also curious to explore encoding the node's shape
        based on its type or function. For example, a method is encoded as a circle and a parameter type as a triangle.
        We would prefer reusing standard shape encodings, but we couldn't find any so far in our initial literature
        review. If methods are exclusively represented as polygons, we briefly considered encoding the method's
        complexity as the polygon's number of sides to give an additional clue for the developer's exploration. Encoding
        the number of sides as a linear relationship might be confusing if the method is very complex. However, the
        method would also most likely be large simultaneously, so its size encoding might mitigate the confusion. If
        anything, it could give a strong signal to the developer that they might want to refactor that method [<a
        href="#ref-refactoring">11</a>]. An alternative would be to split the domain in a stepped range with 3 or 5
        options corresponding to increasing orders of complexity that are easy to parse and non-ambiguous.
      </p>

       <!-- 
         Conclusion
        -->
      <h2 id="ref-conclusion">Conclusion</h2>
      <p>
        In this final course project, I advanced my research, and applied concepts learned in class. Specifically, I
        refined the scope of the research project, explored related work on software visualization, and compared ways to
        visualize network graph adapted to displaying relation between software artifacts, designed and prototyped two
        visualizations to represent an overview of the system and enable the exploration of dependencies at the method
        level from a local perspective.
      </p>
      <p>
        The following steps are two-fold. The first step is to finish implementing the visualization prototypes with all
        the features mentioned in their model design and evaluate them in a small user study. The second step is to
        merge the concepts from the visualizations into one unified visualization where the level of abstraction is
        controlled by zooming, building on the technique of the initial prototype we already evaluated, and integrating
        it with an efficient source code parsing server.
      </p>
      <p>
        In summary, on top of putting into practice what I learned in the course and solidifying my newly-developed D3
        skills, this final project enabled me to make significant headway into this research project regarding
        background, direction, motivation, and working prototypes.
      </p>

      <section>
        <h2>References</h2>
        <p style="font-style: italic; font-size: small;">The references are not ordered by appearance in the text but by date of addition to the reference list below.</p>
        <!-- Vancouver Reference Style -->
        <ol>
          <li id="ref-d3-voronoi-treemap">
            <p>Kcnarf. D3 Voronoi Treemap. <a
                href="https://github.com/Kcnarf/d3-voronoi-treemap">https://github.com/Kcnarf/d3-voronoi-treemap</a>.
              Last accessed 2021-06-06</p>
          </li>
          <li id="ref-balzer-voronoi-treemap">
            <p>Balzer M, Deussen O. Voronoi treemaps. InIEEE Symposium on Information Visualization, 2005. </p>
          </li>
          <li>
            <p>Balzer M, Deussen O, Lewerentz C. Voronoi treemaps for the visualization of software metrics.
              InProceedings of the 2005 ACM symposium on Software visualization 2005</p>
          </li>
          <li id="ref-munzner">
            <p>Munzner T. A nested model for visualization design and validation. IEEE transactions on visualization and
              computer graphics. 2009</p>
          </li>
          <li id="ref-loc">
            <p>Alpernas K, Feldman YM, Peleg H. The wonderful wizard of LoC: paying attention to the man behind the
              curtain of lines-of-code metrics. InProceedings of the 2020 ACM SIGPLAN International Symposium on New
              Ideas, New Paradigms, and Reflections on Programming and Software 2020</p>
          </li>
          <li id="ref-cloc">
            <p>
              AlDanial. cloc. <a href="https://github.com/AlDanial/cloc">https://github.com/AlDanial/cloc</a>. Last accessed 2021-06-09
            </p>
          </li>
          <li id="ref-sourcetrail">
            <p>CoatiSoftware. Sourcetrail. <a href="https://www.sourcetrail.com/">https://www.sourcetrail.com/</a>.
              Last accessed 2021-06-06.</p>
          </li>

          <li id="ref-elmqvist-hierarchical">
            <p>Elmqvist N, Fekete JD. Hierarchical aggregation for information visualization: Overview, techniques, and
              design guidelines. IEEE Transactions on Visualization and Computer Graphics. 2009</p>
          </li>

          <li id="ref-codemap">
            <p>Zhu A, Seo, A, Verma S, Schweizer T. Codemap, <a
                href="https://github.com/amyjzhu/503-hacking/">https://github.com/amyjzhu/503-hacking/</a>. Last
              accessed 2021-06-06.</p>
          </li>

          <li id="ref-gource">
            <p>Caudwell A. Gource, <a href="https://gource.io/">https://gource.io/</a>. Last accessed 2021-06-06.</p>
          </li>

          <li id="ref-refactoring">
            <p>
              Fowler M. Refactoring: improving the design of existing code. Addison-Wesley Professional; 2018 Nov 20.
            </p>
          </li>

          <li id="ref-hierarchical-bundles">
            <p>
              Holten D. Hierarchical edge bundles: Visualization of adjacency relations in hierarchical data. IEEE Transactions on visualization and computer graphics. 2006 Nov 20;12(5):741-8.
            </p>
          </li>

          <li id="ref-pretorius">
            <p>
              Pretorius J, Purchase HC, Stasko JT. Tasks for multivariate network analysis. InMultivariate Network Visualization 2014 (pp. 77-95). Springer, Cham.
            </p>
          </li>

          <li id="ref-codeflower">
            <p>
              Zaninotto F. CodeFlower. <a href="https://github.com/fzaninotto/CodeFlower">https://github.com/fzaninotto/CodeFlower</a>. Last accessed 2021-06-09.
            </p>
          </li>

          <li id="ref-depwheel"><p>
            Zaninotto F. DependencyWheel. <a href="https://github.com/fzaninotto/DependencyWheel">https://github.com/fzaninotto/DependencyWheel</a>. Last accessed 2021-06-09.
          </p></li>

          <li id="ref-grammatech"><p>
            GRAMMATECH. <a href="https://www.grammatech.com/products/code-visualization">https://www.grammatech.com/products/code-visualization</a>. Last accessed 2021-06-09.
          </p></li>

          <li id="ref-designite"><p>
            Designite. <a href="https://www.designite-tools.com/">https://www.designite-tools.com/</a>. Last accessed 2021-06-09.
          </p></li>

          <li id="ref-emerge"><p>
            Lato G. emerge. <a href="https://github.com/glato/emerge">https://github.com/glato/emerge</a>. Last accessed 2021-06-09.
          </p></li>

          <li id="ref-arkit"><p>
            Dyatko M. arkit. <a href="https://www.npmjs.com/package/arkit">https://www.npmjs.com/package/arkit</a>. Last accessed 2021-06-09.
          </p></li>
          
          <li id="ref-ndepend"><p>
            NDepend. <a href="https://www.ndepend.com/">https://www.ndepend.com/</a>. Last accessed 2021-06-09.
          </p></li>

          <li id="ref-imagix"><p>
            Imagix Corp. Imagix. <a href="https://www.imagix.com/index.html">https://www.imagix.com/index.html</a>. Last accessed 2021-06-09.
          </p></li>
          
          <li id="ref-scitools"><p>
            SciTools. Understand. <a href="https://www.scitools.com/">https://www.scitools.com/</a>. Last accessed 2021-06-09.
          </p></li>
          
          <li id="ref-chotisarn-survey">
            <p>
            Chotisarn N, Merino L, Zheng X, Lonapalawong S, Zhang T, Xu M, Chen W. A systematic literature review of modern software visualization. Journal of Visualization. 2020 Aug;23(4):539-58.
            </p>
          </li>

          <li id="ref-diehl">
            <p>
              Diehl S. Software visualization: visualizing the structure, behaviour, and evolution of software. Springer Science & Business Media; 2007 May 1.
            </p>
          </li>

          <li id="ref-snowball">
            <p>
              Wohlin C. Guidelines for snowballing in systematic literature studies and a replication in software engineering. InProceedings of the 18th international conference on evaluation and assessment in software engineering 2014 May 13 (pp. 1-10).
            </p>
          </li>

          <li id="ref-healey-attention">
            <p>Healey C, Enns J. Attention and visual memory in visualization and computer graphics. IEEE transactions on visualization and computer graphics. 2011 Jul 28;18(7):1170-88.</p>
          </li>

          <li id="ref-deutsch">
            <p>L. Peter Deutsch. Deutsch limit. http://www.faqs.org/faqs/visual-lang/faq/. Last accessed 2021-06-09</p>
          </li>

          <li id="ref-tufte">
            <p>Tufte ER, Goeler NH, Benson R. Envisioning information. Cheshire, CT: Graphics press; 1990 Jan 3.</p>
          </li>

        </ol>
      </section>

      <section class="footer">
        <a href="https://courses.cs.washington.edu/courses/cse512/21sp/">CSE 512 Data Visualization</a>
        <a href="http://www.washington.edu">University of Washington</a>
      </section>

      <script src="https://d3js.org/d3.v6.min.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-weighted-voronoi/v1.1.0/build/d3-weighted-voronoi.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-voronoi-map/v2.1.0/build/d3-voronoi-map.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-voronoi-treemap/v1.1.1/build/d3-voronoi-treemap.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script>
      <script src="./js/index.js"></script>
      <script src="./js/data.js"></script>
      <script src="./js/visualization.js"></script>
  </div>
</body>

</html>