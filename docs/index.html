<!DOCTYPE HTML>
<html xml:lang="en" lang="en">

<head>
  <title>CSE512 | Final Project</title>

  <link rel="stylesheet" href="css/site.css">
  <link rel="stylesheet" href="css/vis.css">
</head>

<body>
  <div class="content">
    <section class="title">
      <a href="">Codemap</a>
      <a href="https://github.com/cse512-21s/FP-Codemap">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"
          focusable="false" width="0.75em" height="0.75em"
          style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);"
          preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 250">
          <path
            d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46c6.397 1.185 8.746-2.777 8.746-6.158c0-3.052-.12-13.135-.174-23.83c-35.61 7.742-43.124-15.103-43.124-15.103c-5.823-14.795-14.213-18.73-14.213-18.73c-11.613-7.944.876-7.78.876-7.78c12.853.902 19.621 13.19 19.621 13.19c11.417 19.568 29.945 13.911 37.249 10.64c1.149-8.272 4.466-13.92 8.127-17.116c-28.431-3.236-58.318-14.212-58.318-63.258c0-13.975 5-25.394 13.188-34.358c-1.329-3.224-5.71-16.242 1.24-33.874c0 0 10.749-3.44 35.21 13.121c10.21-2.836 21.16-4.258 32.038-4.307c10.878.049 21.837 1.47 32.066 4.307c24.431-16.56 35.165-13.12 35.165-13.12c6.967 17.63 2.584 30.65 1.255 33.873c8.207 8.964 13.173 20.383 13.173 34.358c0 49.163-29.944 59.988-58.447 63.157c4.591 3.972 8.682 11.762 8.682 23.704c0 17.126-.148 30.91-.148 35.126c0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002C256 57.307 198.691 0 128.001 0zm-80.06 182.34c-.282.636-1.283.827-2.194.39c-.929-.417-1.45-1.284-1.15-1.922c.276-.655 1.279-.838 2.205-.399c.93.418 1.46 1.293 1.139 1.931zm6.296 5.618c-.61.566-1.804.303-2.614-.591c-.837-.892-.994-2.086-.375-2.66c.63-.566 1.787-.301 2.626.591c.838.903 1 2.088.363 2.66zm4.32 7.188c-.785.545-2.067.034-2.86-1.104c-.784-1.138-.784-2.503.017-3.05c.795-.547 2.058-.055 2.861 1.075c.782 1.157.782 2.522-.019 3.08zm7.304 8.325c-.701.774-2.196.566-3.29-.49c-1.119-1.032-1.43-2.496-.726-3.27c.71-.776 2.213-.558 3.315.49c1.11 1.03 1.45 2.505.701 3.27zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033c-1.448-.439-2.395-1.613-2.103-2.626c.301-1.01 1.747-1.484 3.207-1.028c1.446.436 2.396 1.602 2.095 2.622zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95c-1.53.034-2.769-.82-2.786-1.86c0-1.065 1.202-1.932 2.733-1.958c1.522-.03 2.768.818 2.768 1.868zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37c-1.485.271-2.861-.365-3.05-1.386c-.184-1.056.893-2.114 2.376-2.387c1.514-.263 2.868.356 3.061 1.403z"
            fill="#161614" />
          <rect x="0" y="0" width="256" height="250" fill="rgba(0, 0, 0, 0)" />
        </svg>
      </a>
    </section>

    <section>
      <p>
        <strong>Team Members</strong>: Thomas Schweizer
      </p>
      <p>
        <a href="https://www.youtube.com/watch?v=sHH-MWpzAW0">Video presentation</a>
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        As part of an on-going <a href="https://www.notion.so/Codemap-ec02c79cb0b44304ba10767af1ca3788">research
          project</a>, we explore local interactive software visualizations aimed to help developers explore and locate
        information about methods and classes necessary to fix bugs and develop new features. We present our findings
        and results with a short project report and two visualizations.
      </p>

      <p>
        In this project, we explore multiple design concepts as well as related work in software visualization.
      </p>

      <p>
        Previously, we conducted a user study to evaluate if an integrated interactive visualization to an IDE was
        useful to developers to navigate source code, and find related classes and methods. For this we developed a <a
          href="https://github.com/amyjzhu/503-hacking/">rough prototype</a> to support the experiment. The
        visualization used a zooming technique, similar in essence to Google Maps, to move between different levels of
        abstraction.
      </p>

      <p>
        We found that the visualization was generally helpful to the participants. Specifically, the following features
        were promising:

      <ul>
        <li>The visualization is initially centered on the class the user is editing</li>
        <li>Moving seamlessly between levels of abstraction visually (similarly to Google Maps)</li>
        <li>Switching between the source code of a class and its visualization with a click</li>
        <li>Exploring dependencies interactively (by clicking on the edge connecting the methods or classes)</li>
      </ul>
      </p>

      <p>
        We also found that the representation of each level of abstraction was lacking. Participants complained that
        packages, classes, and method were too far apart or too close together, creating occlusion problems in the
        latter case. These issues stem from the force layout we used. We also ran into performance and complexity issues
        with larger code bases that we mitigated with interactive filters and just-in-time rendering.
      </p>

      <p>
        Thus, with this final project, we aim to explore individual visualization to represent different levels of
        abstraction in source code capable of addressing these issues. The visualizations will be focused on working
        from a local perspective (i.e., showing dependencies from a given method rather than showing the entire
        dependency graph) and interactivity based on existing visualization techniques (e.g., Voronoi, Hyperbolic
        Layout, Hierarchical Edge Bundling, Radial Tree).
      </p>

      <p>
        This project will not implement the mechanisms to blend the visualization of the levels of abstraction, this
        will be for another time. Additionally, this project will not focus on the integration between the visualization
        and the IDE because the basic mechanisms were implemented in the previous prototype. Moreover, in the visualization concepts below, we implicitly assume that the visualizations are implemented in the context of a development environment that would update the data model with the most up-to-date information. Crucially, we also implicitly keep the interaction feature of control click introduced in the legacy prototype that enables the user to switch between an element in the visualization to its source code equivalent.
      </p>

      <p>
        The report is organized as follows. 
        First, we explore related work (<a href="#ref-related-work">Related work</a>). 
        Second, we briefly come back to our initial prototype and user study 
        (<a href="#ref-background">Background</a>). 
        Third, we state the main challenges we anticipate to face our visualizations 
        (<a href="#ref-challenges">Challenges</a>).
        Fourth, we design and discuss an overview for visualizing the structure of software 
        (<a href="#ref-structure-overview">Structure overview</a>).
        Fifth, we design and discuss a visualization for exploring local method dependencies 
        (<a href="#ref-local-exploration">Local exploration</a>).
        Finally, we conclude the project with a brief summary 
        (<a href="#ref-conclusion">Conclusion</a>).
      </p>

      <!-- 
        Related work
       -->
      <h2 id="ref-related-work">Related work</h2>
      <p>
        In our initial survey literature, we retained papers that we deemed most relevant and representative to serve as a starting point for snowball sampling [<a href="#ref-snowball">26</a>]. Chotisarn et al., dress an exhaustive portrait of the software visualization research landscape in a recent paper [<a href="#ref-chotisarn-survey">24</a>]. Using a systematic review literature methodology, they retained 105 relevant full papers on software visualization. In addition of highlighting research opportunities, the paper also provide effective tools to orient and scope research in software visualization. This article is thus doubly useful for us. Moreover, they classify the relevant papers by software system aspect (i.e., structure, behavior, evolution [<a href="#ref-diehl">25</a>]), software process (i.e., specification, design & implementation, validation & testing, evolution), and role (i.e., developer, maintainer, manager) as well as visualization technique, mediums and tools.
      </p>

      <p>
        We identified Pretorius et al. [<a href="#ref-pretorius">13</a>] taxonomy for general tasks in graph networks as a promising source to describe and scope the developer's tasks when software is represented with the metaphor of a network graph such as software artifacts (e.g., classes, methods, packages) are represented as nodes and the relations between them (e.g., dependency, inheritance, flow) as edges.
        
        Additionally, Elmqvist et al., [<a href="#ref-elmqvist-hierarchical">8</a>] present a general technique to visualize multi-scale representation of hierarchical information, which is helpful since many aspects of software development are hierarchical (e.g., architecture, dependencies).
      </p>

      <h3>Solutions</h3>
      <p>
        Finally, we explored commercial and open-source solutions to get a picture of the landscape as complete as possible. We found surprisingly many solutions and approaches. Most of them concentrate on audit-type visualizations where big picture is presented to the viewer [<a href="#ref-depwheel">16-21</a>], although a portion of them are bit more "esoteric" such as Gource [<a href="#ref-gource">14</a>] and CodeFlower [<a href="#ref-codeflower">15</a>]. We also found that a minority of solutions are integrated with the developer's workflow [<a href="#ref-ndepend">21-23</a>].
      </p>
      <p>
        We found that NDepend [<a href="#ref-ndepend">21</a>] was the closest to our overall idea, implementing a zooming mechanism enabling the user to drill down at will. See <a href="https://blog.ndepend.com/visualize-code-with-software-architecture-diagrams/">this article</a> for a detailed look. Sourcetrail [<a href="#ref-sourcetrail">7</a>] also caught our attention because it seemed to be the most thoughtful solution out there. Indeed, it addresses a clear problem well and the user interface seems intuitive and well thought-out so as to not overwhelm the viewer.
      </p>

      <h3>Venues</h3>
      <p>
        Through the course and initial literature survey, we identified relevant venues for software visualization such as <a href="https://chi2021.acm.org/">CHI</a>, <a href="https://uist.acm.org">UIST</a>, <a href="http://ieeevis.org/year/2021/welcome">IEEE VIS</a>, <a href="https://vissoft20.dcc.uchile.cl/">IEEE VISSOFT</a>, <a href="https://www.eurovis.org/">EuroVis</a>, and <a href="https://www.springer.com/journal/12650">Journal of Visualization</a>. These references will be helpful to gather the latest state of the art and communicate our research using the methods and conventions used by the visualization community in addition to the software visualization survey paper [<a href="#ref-chotisarn-survey">24</a>].
      </p>

      <!-- 
        Prototype
       -->
      <h2 id="ref-background">Background</h2>
      <p>
        Below, we present an global overview of Codemap using Munzner's nested model [<a href="#ref-munzner">4</a>]. The
        closest working implementation is currently the Codemap prototype used to do the initial user study [<a
          href="#ref-codemap">9</a>]. The goal of the model is to put the accent on the zooming mechanism and general
        philosophy tying in the visualization experience to the integrated environment in a developer-centered
        experience.
      </p>

      <!-- 
        Challenges
       -->
      <h2 id="ref-challenges">Challenges</h2>
      <p>Scalability</p>
      <p>Comnplexity</p>
      <p>Performance</p>
      <p>Other challenges from the report</p>

       <p>Evaluation</p>
       The next step is to evaluate the efficiency and efficacy of the visualizations explored in this project. We
       propose several strategies to evaluate the visualizations based on related work seen in class and in the
       literature.

       <!-- 
        Structure overview
       -->
      <h2 id="ref-structure-overview">Structure overview</h2>
      <p>
        In this prototype, we explore how the class and package hierarchy can be visualized from an initial perspective
        using Voronoi diagrams. For example using <a
          href="https://github.com/Kcnarf/d3-voronoi-treemap">d3-voronoi-treemap</a>.
      </p>

      <p>
        The prototype aims to solve task X.
      </p>

      <details>
        <summary>Nested model for hierarchy concept</summary>
        <div class="nested-model">
          <div class="domain">
            <p><strong>Domain Problem and Data Characterization</strong></p>
            <p>
              We are interested to help the developer build a mental image of the source code. Mental image of the
              source code is necessary before fixing a bug or implementing a new feature to locate artifacts or
              interest.
            </p>
            <p>
              Conducted a user study on a rough visualization prototype integrated to Visual Studio Code as a plugin to
              gather initial feedback. Participants noted that integration was really important and used the zooming
              mechanism to move from low abstraction to high abstraction.
            </p>

            <div class="abstraction">
              <p><strong>Operation and Data Type Abstraction</strong></p>
              <p>Transform the class and package hierarchy into a list of parent and children relations. The hierarchy
                is illustrated with Voronoi treemaps [<a href="#ref-balzer-voronoi-treemap">2</a>];</p>

              <div class="technique">
                <p><strong>Visual Encoding and Interaction Design</strong></p>

                <p>
                  Simple Radial tree with local node centered. Pan and Zoom
                  Interactivity features.
                </p>

                <p>The Voronoi treemap is monochromatic. The cells represent classes and the edges represent class and
                  packages boundaries.</p>

                <p>The current class is encoded with an <span style="background-color:aquamarine">accent color</span>
                  for pre-attentive detection.</p>

                <p>To anchor the representation physically to the viewer, we encode the cell's size with the size of the
                  class. Here, we use the source lines of code (SLOC) metric to represent the size [<a
                    href="#ref-loc">5</a>]. That way, each cell is characterized by its content visually.</p>

                <p>Hovering displays information regarding the class</p>

                <p>Search bar to find a class quickly.</p>

                <p>Control clicking a class, centers the visualization on it</p>

                <p>Inter class or package relations (e.g., dependencies) can be toggled on and off with an extradiegetic
                  interface.</p>

                <div class="algorithm">
                  <p><strong>Algorithm Design</strong></p>
                  <p>
                    Voronoi treemaps [<a href="#ref-d3-voronoi-treemap">1</a>, <a
                      href="#ref-balzer-voronoi-treemap">2</a>]
                  </p>

                  <p>
                    The diagram is seeded so the map doesn't change every time its regenerated even though the content
                    of the data doesn't change. The seed is assigned to the data so every time the data changes, a new
                    map is generated, marking a new version of the data. In a live development setting, we would need a
                    less naive approach. For example, growing the map as changes are made, minimizing displacement of
                    the cells similarly how Gource [<a href="#ref-gource">10</a>], a popular version control
                    visualization, does it.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </details>

      <div id='vis-macro' class="visualization"></div>
      <div id='vis-macro-legend' class="legend"></div>
      <p class="hint">Refresh the page to change the point of view (i.e., current class)</p>

      <!-- 
        Local exploration
       -->
      <h2 id="ref-local-exploration">Local exploration</h2>
      <p>
        In this prototype, we explore how dependencies between methods can be visualized from an initial method using
        radial tree and hierarchical edge bundling.
      </p>

      <p>
        The prototype aims to solve task X.
      </p>

      <details>
        <summary>Nested model for method visualization</summary>
        <div class="nested-model">
          <div class="domain">
            <p><strong>Domain Problem and Data Characterization</strong></p>
            <p>
              We are interested to help the developer build a mental image of the source code. Mental image of the
              source code is necessary before fixing a bug or implementing a new feature to locate artifacts or
              interest.
            </p>
            <p>
              Conducted a user study on a rough visualization prototype integrated to Visual Studio Code as a plugin to
              gather initial feedback. Participants noted that integration was really important and made heavy use of
              click through to go from one method to another. Also found the zooming feature useful to answer questions.
            </p>

            <div class="abstraction">
              <p><strong>Operation and Data Type Abstraction</strong></p>
              <p>Network graph. Edges are links between artifacts. Nodes are methods.</p>

              <div class="technique">
                <p><strong>Visual Encoding and Interaction Design</strong></p>
                <p>Methods are encoded as network nodes. Their size is based on the method's LOC or complexity, the
                  color encodes the return type.</p>

                <p>Methods are attracted by their enclosing class and dependencies.</p>

                <p>The dependencies are encoded as the edges.</p>
                <p>
                  <strong>Interactions:</strong>
                <ul style="list-style: none">
                  <li>Hide / Show artifact</li>
                  <li>Pin / Unpin artifact</li>
                  <li>Navigate: click on links, zoom, pan</li>
                  <li>Drill down / Up artifact: class > method > logic?</li>
                </ul>
                </p>

                <p>
                  Current path is highlighted.
                </p>

                <div class="algorithm">
                  <p><strong>Algorithm Design</strong></p>
                  <p>Voronoi, Hyperbolic Layout?, Hierarchical Edge Bundling, Radial Layout</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </details>

      <div id='method-level' class="visualization"></div>
      <p class="hint">Refresh the page to change the point of view (i.e., current method)</p>

      <p>
        This visualization was a great learning experience.

        This visualization was the hardest to implement and I had to scale down my ambitions to fit in the course's
        timeline. However, I found promising examples online that showcase behaviors that I might implement. In this
        current version however, adjusting the force layout was the most challenging for me, particularly what was the
        right way to center a node in the force system. With this visualization, I was able to acquire a lot of
        experience on the d3 force layout and develop my instincts for what is a good visualization for network graphs
        in the context of software visualization.
      </p>

      <p>
        Hyperbolic layout vs Radial layout.
      </p>

      <p>
        Color is problematic. Solutions
      </p>

      <p>
        As you can see this prototype isn't finished. It lacks several features that would be essential. For example grouping nodes into classes, bundling edges.
      </p>

      <p>
        The visualization was useful in uncovering a few insights
        1) Centering the layout on the method under visualization seem useful. It establishes clearly the object of visualization.
        2) When a method has no edges
      </p>
      <p>
        I know realize that centering the current node was a good first step but is ultimately insufficient. Indeed, as seen in class, showing more isn't always better. In this particular case, displaying all the nodes is doing the developer a disservice since the task we want to support is to help them explore local relationships from a particular method: they do not need to see unrelated classes and methods at all. They are most likely never going to visit random nodes and edge just like they never open random source files to locate information. They always either 1) follow type dependencies or 2) search for a specific artifact. Thus, we refined our design further.
      </p>

      <h3>Second iteration</h3>

      <p>
        For this second design, the amount of information shown is directly controlled by the developer through interaction. The developer would builds the visualization as their own from a minimal initial set of nodes. The hope is that by starting with a minimal visualization, the developer auto-regulate the complexity they need displayed, enabling them to focus on different aspects in function of the information they need at the time.

        Picture this. The visual metaphor is still a network graph with methods and classes represented as nodes, and the edges represent the type of dependencies. The visualization initially shows only direct dependencies related to the method under visualization (referred as 'origin method'). The dependency nodes include type of parameters, type of variables, classes used, method used, and which other methods use the origin method. Incoming and outgoing dependencies are differentiated with corresponding arrows. For example, a node representing a parameter type of the origin method has an incoming arrowed edge to the origin's node while an outgoing arrowed edge would connect to a node representing where the method's is called from. The visualization is still centered on origin method. The related nodes are organized using an augmented force layout where similar nodes tend to group together (e.g., type parameter) or borrowing from topology trees, types or method far away semantically or package wise would be shown less close to the center node than its immediate related nodes such as methods in the same class or package.
        
        Clicking on a node (except the origin) will, in turn, expand the dependencies of the clicked node just like for the origin method and center the visualization on this new node of focus. A breadcrumb mechanism highlights the path (i.e., making the edges thicker) between the origin node and the node currently in focus (or hovered) allowing the developer to visually have a reference for tracing back their steps, much like how Ariadne's thread allowed Theseus to escape the Minotaur's labyrinth in the eponym greek myth. We also include an extra-diegetic control on the bottom left of the visualization allows the developer at any time to focus the visualization back to the origin node so they don't have to follow the breadcrumb. This is especially useful if they have explored a large network and do not want to scroll or pan all the way back.

        Hovering on an edge or a node gives contextual clues such as the name of the method, class and parameter similar to how the quick access documentation might show in an IDE. We prefer keeping the amount of textual information on the graph light to not clutter the graph so the developer is encouraged to explore.

        For the developer's comfort, they can also drag, and pin nodes to arrange their graph how they like or see it. We could imagine an advanced feature where we learn their positioning preference automatically to reposition the nodes for them, relying less on the force layout's idiosyncrasies.

        Similarly to the macro visualization concept, we encode the size of the nodes with the size of the method (e.g., SLOC [<a href="#ref-loc">5</a>]) to give the nodes a "physical" anchor to their counterparts. We hope that this will help developers to intuitively form a connexion between the methods' source code and their visual counterparts.

        Finally, edge bundling could be leverage here when the developer zooms back and forth as a way to highlight common fate patterns and be easier on the eye and performance [<a href="#ref-hierarchical-bundles">12</a>].
      </p>

      <p>
        To further help the developer parse the graph quickly, we would also encode the node's shape depending on it's type or function. For example, a method is encoded as a circle and an parameter type as a triangle. We would prefer reusing standard shape encodings but we couldn't find any so far in our initial literature review. If methods are exclusively represented as polygons, we briefly considered encoding the method's complexity as the polygon's number of sides to give an additional clue for the developer's exploration. Encoding the number of sides as a linear relationship might be confusing if the method is very complex, although the method would most likely be large in size at the same time so its size encoding might mitigating the confusion. If anything, it could give a strong signal to the developer that they might want to refactor that method [<a href="#ref-refactoring">11</a>]. An alternative would be to split the domain in a stepped range with 3 or 5 options corresponding to increasing orders of complexity that's easy to parse and non-ambiguous.
      </p>

      <p>Include diagrams of this design</p>

       <!-- 
         Conclusion
        -->
      <h2 id="ref-conclusion">Conclusion</h2>
      <p>
        With this final course project, I was able to advance my research and apply concepts learned in class.
        Specifically, I refined the scope of the research project, explored related work on software visualization, and
        compared ways to visualize network graph adapted to displaying relation between software artifacts, designed and
        prototyped two visualization to respectively represent the class hierarchy and represent dependencies between
        methods.

        The next steps are two-fold. First, finish implementing the visualization prototypes with all the features
        mentioned in their model design and evaluate them in a small user study. Second, merge the concepts from the
        visualizations into one unified visualization where the level of abstraction is controlled by zooming, building
        on the technique the initial prototype we already evaluated.

        In summary, on top of putting in practice what I learned in the course and solidifying my budding D3 skills,
        this final project enabled me to make significant headway into this research project in terms of background,
        direction, motivation, and working prototypes.
      </p>

      <section>
        <h2>References</h2>
        <p style="font-style: italic; font-size: small;">The references are not ordered by appearance in the text but by date of addition to the reference list below.</p>
        <!-- Vancouver Reference Style -->
        <ol>
          <li id="ref-d3-voronoi-treemap">
            <p>Kcnarf. D3 Voronoi Treemap. <a
                href="https://github.com/Kcnarf/d3-voronoi-treemap">https://github.com/Kcnarf/d3-voronoi-treemap</a>.
              Last accessed 2021-06-06</p>
          </li>
          <li id="ref-balzer-voronoi-treemap">
            <p>Balzer M, Deussen O. Voronoi treemaps. InIEEE Symposium on Information Visualization, 2005. </p>
          </li>
          <li>
            <p>Balzer M, Deussen O, Lewerentz C. Voronoi treemaps for the visualization of software metrics.
              InProceedings of the 2005 ACM symposium on Software visualization 2005</p>
          </li>
          <li id="ref-munzner">
            <p>Munzner T. A nested model for visualization design and validation. IEEE transactions on visualization and
              computer graphics. 2009</p>
          </li>
          <li id="ref-loc">
            <p>Alpernas K, Feldman YM, Peleg H. The wonderful wizard of LoC: paying attention to the man behind the
              curtain of lines-of-code metrics. InProceedings of the 2020 ACM SIGPLAN International Symposium on New
              Ideas, New Paradigms, and Reflections on Programming and Software 2020</p>
          </li>
          <li id="ref-loc">
            <p>
              AlDanial. cloc. <a href="https://github.com/AlDanial/cloc">https://github.com/AlDanial/cloc</a>. Last accessed 2021-06-09
            </p>
          </li>
          <li id="ref-sourcetrail">
            <p>CoatiSoftware. Sourcetrail. <a href="https://www.sourcetrail.com/">https://www.sourcetrail.com/</a>.
              Last accessed 2021-06-06.</p>
          </li>

          <li id="ref-elmqvist-hierarchical">
            <p>Elmqvist N, Fekete JD. Hierarchical aggregation for information visualization: Overview, techniques, and
              design guidelines. IEEE Transactions on Visualization and Computer Graphics. 2009</p>
          </li>

          <li id="ref-codemap">
            <p>Zhu A, Seo, A, Verma S, Schweizer T. Codemap, <a
                href="https://github.com/amyjzhu/503-hacking/">https://github.com/amyjzhu/503-hacking/</a>. Last
              accessed 2021-06-06.</p>
          </li>

          <li id="ref-gource">
            <p>Caudwell A. Gource, <a href="https://gource.io/">https://gource.io/</a>. Last accessed 2021-06-06.</p>
          </li>

          <li id="ref-refactoring">
            <p>
              Fowler M. Refactoring: improving the design of existing code. Addison-Wesley Professional; 2018 Nov 20.
            </p>
          </li>

          <li id="ref-hierarchical-bundles">
            <p>
              Holten D. Hierarchical edge bundles: Visualization of adjacency relations in hierarchical data. IEEE Transactions on visualization and computer graphics. 2006 Nov 20;12(5):741-8.
            </p>
          </li>

          <li id="ref-pretorius">
            <p>
              Pretorius J, Purchase HC, Stasko JT. Tasks for multivariate network analysis. InMultivariate Network Visualization 2014 (pp. 77-95). Springer, Cham.
            </p>
          </li>

          <li id="ref-gource"><p>https://gource.io/</p></li>
          <li id="ref-codeflower"><p>https://github.com/fzaninotto/CodeFlower</p></li>

          <li id="ref-depwheel"><p>https://github.com/fzaninotto/DependencyWheel</p></li>
          <li id="ref-grammatech"><p>https://www.grammatech.com/products/code-visualization</p></li>
          <li id="ref-designite"><p>https://www.designite-tools.com/</p></li>
          <li id="ref-emerge"><p>https://github.com/glato/emerge</p></li>
          <li id="ref-arkit"><p>https://www.npmjs.com/package/arkit</p></li>
          
          <li id="ref-ndepend"><p>https://www.ndepend.com/</p></li>
          <li id="ref-imagix"><p>https://www.imagix.com/index.html</p></li>
          <li id="ref-scitools"><p>https://www.scitools.com/</p></li>
          <li id="ref-chotisarn-survey">
            <p>
            Chotisarn N, Merino L, Zheng X, Lonapalawong S, Zhang T, Xu M, Chen W. A systematic literature review of modern software visualization. Journal of Visualization. 2020 Aug;23(4):539-58.
            </p>
          </li>

          <li id="ref-diehl">
            <p>
              Diehl S. Software visualization: visualizing the structure, behaviour, and evolution of software. Springer Science & Business Media; 2007 May 1.
            </p>
          </li>

          <li id="ref-snowball">
            <p>
              Wohlin C. Guidelines for snowballing in systematic literature studies and a replication in software engineering. InProceedings of the 18th international conference on evaluation and assessment in software engineering 2014 May 13 (pp. 1-10).
            </p>
          </li>

        </ol>
      </section>

      <section class="footer">
        <a href="https://courses.cs.washington.edu/courses/cse512/21sp/">CSE 512 Data Visualization</a>
        <a href="http://www.washington.edu">University of Washington</a>
      </section>

      <script src="https://d3js.org/d3.v6.min.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-weighted-voronoi/v1.1.0/build/d3-weighted-voronoi.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-voronoi-map/v2.1.0/build/d3-voronoi-map.js"></script>
      <script src="https://rawcdn.githack.com/Kcnarf/d3-voronoi-treemap/v1.1.1/build/d3-voronoi-treemap.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script>
      <script src="./js/index.js"></script>
      <script src="./js/data.js"></script>
      <script src="./js/visualization.js"></script>
  </div>
</body>

</html>